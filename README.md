# serial-synapse
tldr - Orchestrates serial communication to MCU device utilizing CmdMessenger protocol

This sounds a lot more complicated than it is, so I will have some easy to use example code soon!

## Update Handlers vs Commands
*serial-synapse* implements both **commands** and **update handlers**.

* **Commands** are executed at the behest of the master, triggering functionality/a response from the secondary.
* **Commands** can either be silent (no response generated) or responsive (default, a response will occur to this command, feeding back data or an acknowledgement of command execution)
* **Update Handlers** have a function triggered when the secondary fires back information with its identifier. A good example would be a sensor detecting collision, or periodic updates of an accelerometer or distance sensor.

##Example Usage:
In this simple example, we're going to set up CmdMessenger on an Arduino (I'm assuming an Uno) - and placing a button on pin 4. The Uno has an LED already on pin 13. We're going to have node blink the LED every second, reporting back once it's done. We're also going to have a console log of when the button switches states.

On our Arduino:
```
#include <CmdMessenger.h>

#define LED_PIN 13
#define BUTTON_PIN 4

CmdMessenger cmdMessenger = CmdMessenger(Serial);
int lastValue = 0;

enum
{
	kSetLED,
	kButton
};

void setup()
{
	Serial.begin(9600);
	pinMode(LED_PIN, OUTPUT);
	pinMode(BUTTON_PIN, INPUT);
}

void setLED(){
	char* uuid = cmdMessenger.readStringArg();
	int ledStatus = cmdMessenger.readIntArg();
	
	digitalWrite(LED_PIN, ledStatus);
	
	Serial.print(uuid);
	Serial.println(ledStatus);
}

void loop()
{
	cmdMessenger.feedinSerialData();
	
	cmdMessenger.attach(kSetLED, setLED);
	
	//Check the button and if we need to trigger the update handler
	int buttonValue = digitalRead(BUTTON_PIN);
	if(lastValue != buttonValue){
		lastValue = buttonValue;
		Serial.print(kButton);
		Serial.print(",");
		Serial.println(buttonValue);
	}
}
```
On your master:
```
var SerialSynapse = require('serial-synapse');
var SerialPort = require('serialport').SerialPort;
var parsers = require('serialport').parsers;

var arduino = new SerialSynapse();

arduino.addUpdateHandler(
  {
    name: 'button',
    identifier: 1,
    returns: ["buttonState"],
    then: function(data){
      console.log("The button has been " + data.buttonState ? "pressed" : "released");
    }
  }
);

arduino.addCommand(
  {
    name: 'setLED',
    identifier: 0,
    returns: ['ledState']
  }
);

arduino.connection = new SerialPort('COM13',
	{
		baudrate: 9600,
		parser: parsers.readline('\r\n')
	}
);

var ledState = 0;
setInterval(function(){
  arduino.setLED(ledstate, function(data){
    ledState = ledState ? 0 : 1;
    console.log("LED has been set to " + data.ledState);
  });
}, 1000);

```

##Messaging Protocol
Wherein we discuss the expected communication protocol between master and secondary, where *master* is your node process and *secondary* is your MCU/Arduino/robot/IoT Toaster:

###From master (node) to secondary (MCU):
```
identifier,uuid,args,args,args;
```
* *identifier* - the enum identifying what function to execute
* *uuid* - this is generated by *serial-synapse* if the function is not "silent", and needs to be echoed back first by the MCU so we know it's responding to the command.
* *args*, args, args - *n* arguments, from 0 to any number, that your function on the MCU may need to execute
* **;** - CmdMessenger parses messages by scanning for the **;**, so we include this at the end of our message.

For example:
```
0,dfegjk,25,47,13;
```

###From secondary to MCU:
```
identifier/uuid,data,data,data
```
* *identifier/uuid* - If the data coming back is in response to a command, a uuid is passed first - the same passed to execute the command. This notifies serial-synapse that the function has complete, and the follow message is for it. If it is an update handler, just the identifier is used to let *serial-synapse* know that it needs to trigger the update handler function.
* *data, data, data* - *n* data, seperated by commas. No limits to how much or little data can be passed
* *parsing the end* - Please read on serialport parses its "lines". I use "\r\n" to detect a newline as my parser. *synapse-serial* does not care HOW you denote the differentiation between these lines, but it needs to be set via the serialport instance.

# Why use this?
Let's say that you want a quick and easy control mechanism for your custom hardware on Arduino or an MCU. If you write your embedded code using CmdMessenger style response system, you can quickly create a nice functional javascript object to control your hardware.


# TODO:
1 - Tests should be written to ensure that this module works as required

2 - Better documentation
